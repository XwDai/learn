

>GO语言是静态类型。这意味着改变类型需要重新编译。

#### 一. gopath

* 指向一个或多个工作区间。

>没有添加gopath的话，不同包之间的导入是会报错的。goland需要配置project gopath。

#### 二. 构建与安装

* 构建：go build。

* 安装：go install。

* 构建和安装都会执行编译、打包等操作，操作生成的任何文件都会先保存到某个临时目录。

* 构建库源码文件：结果文件只会存在于临时目录，意义主要在于检查和验证。

* 构建命令源码文件：结果文件会搬到源码文件所在的目录。

* 安装操作会先执行构建，然后在链接，并把结果文件搬运到指定目录。

  安装库源码文件：结果文件搬运到所在工作区pkg目录下的某个子目录。

  安装命令源码文件：结果文件搬运到所在工作区的bin目录下或者环境变量gobin指向的目录。

* 构建时，默认不会构建目标代码包所依赖的代码包，如果依赖代码包的归档文件不存在，或者源码文件有变化，还是会编译的。如果需要强制编译，可以在命令中加入标记“-a”，此时，不管是目标代码，还是依赖包，即使是标准库也都会被编译。另外，如果不但要编译依赖的包，还要安装它们的归档文件，可以加上标记“-i”。

* 确定哪些代码包被编译方法：

  * 加上“-x”，可以看到build 执行了哪些操作，另外，加上“-n” ，只查看具体操作而不执行。
  * 加上“-v”，可以看到编译的代码包名称，与“-a” 标记搭配时很有用。

* go get：会自动从一些主流的公用代码库下载目标代码包，并把他们安装到环境变量gopath包含的第一个工作区相应目录中。如果存在环境变量gobin，那么仅包含命令源码文件的代码包会被安装到gobin指向的那个目录。

  * -u：下载并安装代码包，不论工作区是否存在他们。
  * -d：只下载代码包，不安装代码包。
  * -fix：在下载代码包后先运行一个根据当前go语言版本修正代码的工具，然后在安装代码包。
  * -t：同时下载测试需要的代码包。
  * -insecure：允许通过非安全的网络协议下载和安装代码包。http就是这样的协议。

  go get比较基础，不提供依赖管理的功能。

#### 三. Go项目结构

> Go_project
>
> > bin：安装产生的可执行文件
>
> > pkg：安装产生的归档文件，pkg和归档文件中间还有一层目录，叫平台相关目录，名称由build目标系统+“_”+目标计算架构的代号组成，如：linux_amd64 、windows_amd64。
>
> > src：源码文件，会以代码包的的形式组织起来，一个代码包对应一个目录。

> GO项目中，变量和包声明和导入，必需有被使用，不然会报错。GO语句是没有分号分隔的。

#### 四. 源文件

> 注意：
>
> 1. 同目录下的源码文件的代码包声明语句要一致。它们要同属于一个代码包。这对于所有源码文件都是适用的。
> 2. 源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。
> 3. 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。
> 4. 在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：模块级私有。具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的**直接**父包及其**子包**中的代码引用。当然，引用前需要先导入这个internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译。

#####1.  命令源码文件

   * 如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么就是命令文件。

   * 对于一个独立的程序来说，命令源码文件只会也只有一个。

   * 通过命令源码文件生成的可执行文件具备接收参数的能力。

     ```go
     package main
     
     import (
     		"fmt"
     	"flag"
     	)
     
     var name string
     
     var cmLine = flag.NewFlagSet("", flag.PanicOnError)
     
     func init() {
     	//flag.StringVar(&name,"name","everyone","the greeting object.")
     	//flag.Usage = func() {
     	//	fmt.Fprintf(os.Stderr,"Usage of %s :\n ","question")
     	//	flag.PrintDefaults()
     	//}
     	//flag.CommandLine = flag.NewFlagSet("",flag.PanicOnError)
     	//flag.CommandLine.Usage = func() {
     	//		fmt.Fprintf(os.Stderr,"Usage of %s :\n ","question")
     	//		flag.PrintDefaults()
     	//}
     
     	cmLine.StringVar(&name, "name", "everyone", "the greeting object.")
     }
     func main() {
     
     	//flag.Parse()
         //获取命令参数
     	var ags = os.Args[1:]
     	cmLine.Parse(ags)
     	fmt.Printf("hello,%s!\n", name)
     
     }
     ```

     

#####2. 库源码文件

> 特点：不能直接运行，仅存放程序实体（变量、常量、函数、结构体和接口的总称，程序实体的名字统称为标识符，标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。）

#####3. 测试源码文件

##### 4. 程序实体

> 程序实体包括：变量、常量、函数、结构体和接口。

1. 声明变量的方式：

* var name string = "daixw"
* var name = "daixw"  //类型推断
* name:="daixw"  //短变量声明。只能在函数体内部使用。在编写if、for和switch语句的时候，经常把它安插在初始语句中，并用来声明一些临时变量。

​     短变量的其他玩法：变量重声明。

​     变量重声明条件：

1. 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。

2. 变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么是没有问题的，只是需要注意的是：外层代码块用到的变量值是外层代码块声明的值，内层代码块用内层的声明的值，如果没有才会去找外层的。有个点需要区别：变量的重新赋值是不同的，这点与java相同。如：nam = “小轩”，

3. 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。

4. 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。

   注意：**变量重声明可以是不同类型，但是变量重新赋值是不允许不同类型的，编译时已经确定了类型。**

   例子：

  ```go
import (
	"fmt"
	"io"
	"os"
)

func main() {
	var err error
	n, err := io.WriteString(os.Stdout, "Hello, everyone!\n") // 这里对`err`进行了重声明。
	if err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Printf("%d byte(s) were written.\n", n)

}
  ```

2. 包的导入：import “fmt”   ，import （“fmt”,"strings"）

* 一般需要加上包的限定符作为前缀，如fmt.，才能引用包中的程序体。但也可以使用如：import . "fmt"   方式，这种就不需要加前缀，等价于java中的静态导入。

* 怎么判断一个变量的类型？：使用类型断言表达式。、

  * 语法：x.(T)，x:要判断类型的值，必须是接口类型，具体哪个接口类型无所谓，interface{}代表空接口(**一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）**)任何类型都是它的实现类型，比如struct{}:空结构体类型。T:类型

  ```go
  import (
  	"fmt"
  )
  
  var container = []string{"zero", "one", "two"}
  
  func main() {
  	container := map[int]string{0: "zero", 1: "one", 2: "two"}
  
  	// 方式1。
      //interface{} 空接口
      //返回值bool类型(第二个参数)，可以没有，但是当判断为否时就会引发异常(panic,运行时异常)，
      //除非显示恢复,否则会引起程序崩溃。
  	_, ok1 := interface{}(container).([]string)
  	_, ok2 := interface{}(container).(map[int]string)
  	if !(ok1 || ok2) {
  		fmt.Printf("Error: unsupported container type: %T\n", container)
  		return
  	}
  	fmt.Printf("The element is %q. (container type: %T)\n",
  		container[1], container)
  
  	// 方式2。
  	elem, err := getElement(container)
  	if err != nil {
  		fmt.Printf("Error: %s\n", err)
  		return
  	}
  	fmt.Printf("The element is %q. (container type: %T)\n",
  		elem, container)
  }
  
  func getElement(containerI interface{}) (elem string, err error) {
  	switch t := containerI.(type) {
  	case []string:
  		elem = t[1]
  	case map[int]string:
  		elem = t[1]
  	default:
  		err = fmt.Errorf("unsupported container type: %T", containerI)
  		return
  	}
  	return
  }
  ```

* 很常用并且非常值得注意的知识点，一些“陷阱”。

  * 首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。

    ```go
    //求反加1
    var srcInt = int16(-255)
    //去除高8位
    dstInt := int8(srcInt)
    ```

  * 第二，虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）。比如string(-1)，返回的就是�。

  * 第三个知识点是关于string类型与各种切片类型之间的互转的。

    ```go
    //一个值在从string类型向[]byte类型转换时代表着以UTF-8 编码的字符串会被拆分成零散、独立的字节。
    string([]byte{'\xe4', '\xbd','\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
    //一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符。
    string([]rune{'\u4F60', '\u597D'}) // 你好
    ```

* 什么是别名类型，什么是潜在类型。

  * type关键字声明自定义的各种类型

  * 别名类型：

    ```go
    type MyString = string //MyString是string的别名。
    type MyString2 string // 类型再定义，string可以被称为MyString2的潜在类型，潜在类型的含义是某个类型在本质上是哪个类型或者是哪个类型的集合， MyString2与string是两个不同类型，潜在类型相同的不同类型的值之间是可以进行类型转换的，两个类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。
    ```

    它们是完全相同的。别名类型主要是为了代码重构而存在。Go 语言内建的基本类型中就存在两个别名类型，byte是uint8的别名类型，rune是int32别名类型。

* 数组和切片

  * 数组：长度固定，声明时就必须给定。数组能直接用=和!=。例：var a [4]int；var s []int->这个就是切片了

  * 切片：值是可变长的，不能判等操作。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减少。切片的底层数据结构中一定会包含数组。

    注意：**Go 语言的切片类型属于引用类型，同属引用类型的还有后面会讲到的字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。**

  * 切片容量代表了底层数组的长度，仅限于使用make函数或切片值字面量初始化切片的情况。更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。**切片代表的窗口是无法向左扩展的，只能向右，直至其底层数组的末尾**。

  * 切片容量的增长：切片无法容纳更多的元素，会生成一个更大容量的切片，然后把原有元素和新元素一起拷贝到新切片中，一般情况下，新切片是原切片容量的2倍，但是当原切片长度大于或等于1024时，会以原容量的1.25被作为新容量的基准。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。**最终，新容量往往会比新长度大一些，当然，相等也是可能的。**

    另外，如果我们一次追加的元素过多，以至于使新长度比原容量的2 倍还要大，那么新容量就会以新长度为基准。

  * **一个切片的底层数组永远不会被替换**。为什么？虽然在扩容的时候Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。**在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新底层数组的新切片**。

    注意：切片未扩容之前，append会同时替换底层数组对应元素，当切片容量大于底层数组容量，切片扩容，会生成新的底层数组，对应新的切片，这个时候原底层数组是不会作用到了。

    数组

####五. container包中的容器

#####一.List

> 链表，len复杂度为o(1)。

#####二.Ring

> 循环链表，len复杂度为o(n)。

####六.字典(map)

> 键值对集合，hash table的特定实现，键的类型受限（不可以是函数类型、字典类型、切片类型，键类型需要支持判等操作，如果包括了这些限制类型，运行时会panic），值可以是任意类型。

1. 类型的宽度：单个值需要占用的字节数。宽度越小的类型求hash的速度越快。高级类型，如数组求hash，是依次求的它每个元素的哈希值并进行合并，所以速度取决于它的元素类型以及它的长度。对于结构体类型，求hash就是对他所有字段值求hash并合并，所以关键在它各字段的类型以及字段数量。对于接口类型，则是由值得实际类型决定。

   **注意：不建议用高级类型作为键。不仅求hash和判断速度慢，更因为它们的值中存在变数。比如数组，可以改变其元素值，变化后，它已经是不同的键值了。对于结构体可能情况好些，可以控制各字段的访问权限来阻止外界修改。把接口类型作为键时最危险的。**

   类型选优：选基本类型，优先选数值类型和指针类型。如果非要选字符串的话，最好对键值长度有约束。

   GO语言有时会对字典的crud做一些优化。

2. 字典是引用类型，只声明不初始化的话，值是nil。在值为nil的字典上做添加操作会panic，其他操作没有问题。

3. 并发安全map：sync.Map